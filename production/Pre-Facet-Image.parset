##################################################################################
# Pre-Facet-Image Production Pipeline                                            #
#                                                                                #
# Pipeline to do the imaging of the target data:                                 #
# - intended for use in production runs on CEP                                   #
# - requires LOFAR software version  >= 2.17                                     #
# - requires WSClean software version >= 2.5                                     #
# - expects shared filesystem, that all nodes can reach all files!               #
#                                                                                #
# For this pipeline to work the data must have:                                  #
# - in the DATA column:                                                          #
#   - the average amplitude scale set                                            #
#   - the average clock offsets removed                                          #
#   - the LOFAR beam towards the phase center corrected                          #
# - in the CORRECTED_DATA column:                                                #
#   - the DATA calibrated with the gains in supplied the                         #
#     direction-indepndent parmDB                                                #
# The Pre-Facet pipelines will supply exactly this kind of data.                 #
##################################################################################

##########################################
### parameters you will need to adjust  ##
##########################################

## information about the input data
! data_input_path          = /data/scratch/drabent             ## specify the directory where your concatenated target data are stored
! data_input_pattern       = L*.pre-cal.ms                     ## regular expression pattern of all your calibrator files
! direction_indep_parmDBs  = /instrument_directionindependent  ## name of the direction independent parmDBs inside the measurement sets

## location of the software
! prefactor_directory      =  $PREFACTOR_PATH      ## path to your prefactor copy
! wsclean_executable       =  $WSCLEAN_EXECUTABLE  ## path to your local WSClean executable

##########################################
###  parameters you may want to adjust  ##
##########################################

## imaging parameters
! cellsize_highres_deg     = 0.00208  ## cellsize in degrees, 0.00208 deg is about 7.5 arcsec
! fieldsize_highres        = 2.5      ## size of the image is this value times the FWHM of mean semi-major axis of the station beam
! maxlambda_highres        = 7000     ## maximum uv-distance in lambda that will be used for imaging
! image_padding            = 1.4      ## how much padding shall we add during the imaging?
! axis_stretch             = 1.0      ## how much shall the y-axis be stretched or compressed?
! idg_mode                 = hybrid   ## IDG mode to use: cpu or hybrid

## pipeline performance
! max_imagers_per_node     =  2      ## number of simultaneous imager process per node
! max_percent_mem_per_img  =  45     ## max memory (as % of total) per imager process
! max_cpus_per_img         =  20     ## number of cpus per imager process
! error_tolerance          =  False  ## set this to True if you want the pipeline run to continue if single bands fail

## main directories
! lofar_directory          =  $LOFARROOT                  ## base directory of your LOFAR installation
! job_directory            =  input.output.job_directory  ## directory of the prefactor outputs

## script and plugin directories
! scripts                  =  {{ prefactor_directory }}/scripts
pipeline.pluginpath        =  {{ prefactor_directory }}/plugins

## result and scratch directories
! results_directory        =  {{ job_directory }}/results         ## location of the results
! inspection_directory     =  {{ results_directory }}/inspection  ## directory where the images will be stored
! local_scratch_dir        =  /tmp                                ## scratch directory for wsclean (can be local to the processing nodes!)


########################################################
##                                                    ##
##   BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!   ##
##                                                    ##
########################################################

# which steps to run
pipeline.steps = [create_ms_map, combine_mapfile, do_magic, do_magic_maps, combine_mapfile_deep,  wsclean_high_deep, createmap_high_deep_image, make_source_list, move_high_deep, make_image_metadata]


# create a mapfile with all MSs, length = nfiles
create_ms_map.control.kind                      =   plugin
create_ms_map.control.type                      =   createMapfile
create_ms_map.control.method                    =   mapfile_from_folder
create_ms_map.control.mapfile_dir               =   input.output.mapfile_dir
create_ms_map.control.filename                  =   create_ms_map.mapfile
create_ms_map.control.folder                    =   {{ data_input_path }}
create_ms_map.control.pattern                   =   {{ data_input_pattern }}

# generate a mapfile with all files in a single entry, length = 1
combine_mapfile.control.kind                    =  plugin
combine_mapfile.control.type                    =  createMapfile
combine_mapfile.control.method                  =  mapfile_all_to_one
combine_mapfile.control.mapfile_in              =  create_ms_map.output.mapfile
combine_mapfile.control.mapfile_dir             =  input.output.mapfile_dir
combine_mapfile.control.filename                =  combine_mapfile.mapfile

# compute frequency groupings, image sizes, averaging values, etc., len = different
# the deep version of the do_magic_script should return mapfiles sorted by increasing frequency
do_magic.control.type                           =  pythonplugin
do_magic.control.executable                     =  {{ scripts }}/InitSubtract_deep_sort_and_compute.py
do_magic.argument.flags                         =  [combine_mapfile.output.mapfile]
do_magic.argument.outmapname                    =  do_magic.datamap
do_magic.argument.mapfile_dir                   =  input.output.mapfile_dir
do_magic.argument.cellsize_highres_deg          =  {{ cellsize_highres_deg }}
do_magic.argument.fieldsize_highres             =  {{ fieldsize_highres }}
do_magic.argument.image_padding                 =  {{ image_padding }}
do_magic.argument.y_axis_stretch                =  {{ axis_stretch }}

# convert the output of do_magic into usable mapfiles,len = 1 / different
do_magic_maps.control.kind                           =  plugin
do_magic_maps.control.type                           =  mapfilenamesFromMapfiles
do_magic_maps.control.mapfile_nbands_map             =  do_magic.output.nbands.mapfile
do_magic_maps.control.mapfile_nchansout_clean1_map   =  do_magic.output.nchansout_clean1.mapfile
do_magic_maps.control.mapfile_groupmap               =  do_magic.output.groupmap.mapfile
do_magic_maps.control.mapfile_single_map             =  do_magic.output.single_mapfile.mapfile
do_magic_maps.control.mapfile_deep_high_size_map     =  do_magic.output.deep_high_size_mapfile.mapfile

# generate a mapfile with all files in a single entry, length = 1
combine_mapfile_deep.control.kind                    =  plugin
combine_mapfile_deep.control.type                    =  createMapfile
combine_mapfile_deep.control.method                  =  mapfile_all_to_one
combine_mapfile_deep.control.mapfile_in              =  do_magic_maps.output.single_map
combine_mapfile_deep.control.mapfile_dir             =  input.output.mapfile_dir
combine_mapfile_deep.control.filename                =  combine_mapfile_deep.mapfile

# first high-res imaging, length = 1
# TODO: enable primary-beam correction for MFS image (add "-grid-with-beam" to inputkeys)
wsclean_high_deep.control.kind                      =   recipe
wsclean_high_deep.control.type                      =   executable_args
wsclean_high_deep.control.executable                =   {{ wsclean_executable }}
wsclean_high_deep.control.outputsuffixes            =   [-MFS-image.fits,-MFS-model.fits]
wsclean_high_deep.control.outputkey                 =   name
wsclean_high_deep.control.args_format               =   wsclean
wsclean_high_deep.control.max_per_node              =   1
wsclean_high_deep.control.error_tolerance           =   {{ error_tolerance }}
wsclean_high_deep.control.mapfiles_in               =   [combine_mapfile_deep.output.mapfile,do_magic_maps.output.deep_high_size_map,do_magic_maps.output.nchansout_clean1_map]
wsclean_high_deep.control.inputkeys                 =   [msfile,outputsize,nchansout_clean1]
wsclean_high_deep.argument.flags                    =   [-no-update-model-required,-reorder,-fit-beam,-join-channels,-use-idg,msfile]
wsclean_high_deep.argument.size                     =   outputsize
wsclean_high_deep.argument.padding                  =   {{ image_padding }}
wsclean_high_deep.argument.channels-out             =   nchansout_clean1
wsclean_high_deep.argument.niter                    =   400000
wsclean_high_deep.argument.threshold                =   0.0
wsclean_high_deep.argument.pol                      =   I
wsclean_high_deep.argument.weight                   =   briggs 0.0
wsclean_high_deep.argument.mgain                    =   0.65
wsclean_high_deep.argument.minuv-l                  =   80
wsclean_high_deep.argument.maxuv-l                  =   {{ maxlambda_highres }}
wsclean_high_deep.argument.scale                    =   {{ cellsize_highres_deg }}
wsclean_high_deep.argument.mem                      =   {{ max_percent_mem_per_img }}
wsclean_high_deep.argument.j                        =   {{ max_cpus_per_img }}
wsclean_high_deep.argument.weighting-rank-filter    =   3
wsclean_high_deep.argument.temp-dir                 =   {{ local_scratch_dir }}
wsclean_high_deep.argument.auto-mask                =   3.3
wsclean_high_deep.argument.auto-threshold           =   0.5
wsclean_high_deep.argument.local-rms-window         =   50
wsclean_high_deep.argument.local-rms-method         =   rms-with-min
wsclean_high_deep.argument.idg-mode                 =   {{ idg_mode }}

# create a map with the wsclean MFS image only, length = 1
createmap_high_deep_image.control.kind              =   plugin
createmap_high_deep_image.control.type              =   createMapfile
createmap_high_deep_image.control.method            =   mapfile_from_folder
createmap_high_deep_image.control.mapfile_dir       =   input.output.mapfile_dir
createmap_high_deep_image.control.filename          =   wsclean_high_deep_image.mapfile
createmap_high_deep_image.control.folder            =   input.output.working_directory/input.output.job_name
createmap_high_deep_image.control.pattern           =   *wsclean_high_deep-MFS-image.fits

# make source list for the high-res image, length = 1
# Note: until image is primary-beam corrected, fluxes will be apparent
make_source_list.control.type                       =   pythonplugin
make_source_list.control.executable                 =   {{ scripts }}/make_source_list.py
make_source_list.control.max_per_node               =   {{ max_imagers_per_node }}
make_source_list.control.error_tolerance            =   {{ error_tolerance }}
make_source_list.control.mapfile_in                 =   createmap_high_deep_image.output.mapfile
make_source_list.control.inputkey                   =   imagefile
make_source_list.control.outputkey                  =   catalogfile
make_source_list.argument.flags                     =   [imagefile,catalogfile]
make_source_list.argument.threshisl                 =   3.0
make_source_list.argument.threshpix                 =   5.0
make_source_list.argument.atrous_do                 =   True
make_source_list.argument.rmsbox                    =   (60,20)
make_source_list.argument.adaptive_rmsbox           =   True

# copy the high image to where we want it
move_high_deep.control.kind                         =  recipe
move_high_deep.control.type                         =  executable_args
move_high_deep.control.executable                   =  /bin/cp
move_high_deep.control.max_per_node                 =  1
move_high_deep.control.mapfile_in                   =  createmap_high_deep_image.output.mapfile
move_high_deep.control.inputkey                     =  source
move_high_deep.control.arguments                    =  [source,{{ inspection_directory }}]

# make feedback metadata for the output image
make_image_metadata.control.kind                    =   feedback
make_image_metadata.control.type                    =   get_metadata
make_image_metadata.control.mapfile_in              =   createmap_high_deep_image.output.mapfile
make_image_metadata.control.inputkey                =   img
make_image_metadata.control.metadata_file           =   input.output.working_directory/input.output.job_name/image.metadata
make_image_metadata.control.product_type            =   SkyImage
make_image_metadata.control.arguments               =   [img]
